package managers

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	lxd "github.com/lxc/lxd/shared"

	"github.com/battlecrate/distrobuilder/shared"
)

// NewApt creates a new Manager instance.
func NewApt() *Manager {
	return &Manager{
		commands: ManagerCommands{
			clean:   "apt-get",
			install: "apt-get",
			refresh: "apt-get",
			remove:  "apt-get",
			update:  "apt-get",
		},
		flags: ManagerFlags{
			clean: []string{
				"clean",
			},
			global: []string{
				"-y",
			},
			install: []string{
				"install",
			},
			remove: []string{
				"remove", "--auto-remove",
			},
			refresh: []string{
				"update",
			},
			update: []string{
				"dist-upgrade",
			},
		},
		RepoHandler: func(repoAction shared.DefinitionPackagesRepository) error {
			var targetFile string

			if repoAction.Name == "sources.list" {
				targetFile = filepath.Join("/etc/apt", repoAction.Name)
			} else {
				targetFile = filepath.Join("/etc/apt/sources.list.d", repoAction.Name)

				if !strings.HasSuffix(targetFile, ".list") {
					targetFile = fmt.Sprintf("%s.list", targetFile)
				}

			}

			if !lxd.PathExists(filepath.Dir(targetFile)) {
				err := os.MkdirAll(filepath.Dir(targetFile), 0755)
				if err != nil {
					return err
				}
			}

			f, err := os.OpenFile(targetFile, os.O_CREATE|os.O_RDWR, 0644)
			if err != nil {
				return err
			}
			defer f.Close()

			content, err := ioutil.ReadAll(f)
			if err != nil {
				return err
			}

			// Truncate file if it's not generated by distrobuilder
			if !strings.HasPrefix(string(content), "# Generated by distrobuilder\n") {
				err = f.Truncate(0)
				if err != nil {
					return err
				}

				_, err = f.Seek(0, 0)
				if err != nil {
					return err
				}

				_, err = f.WriteString("# Generated by distrobuilder\n")
				if err != nil {
					return err
				}
			}

			_, err = f.WriteString(repoAction.URL)
			if err != nil {
				return err
			}

			// Append final new line if missing
			if !strings.HasSuffix(repoAction.URL, "\n") {
				_, err = f.WriteString("\n")
				if err != nil {
					return err
				}
			}

			if repoAction.Key != "" {
				var reader io.Reader

				if strings.HasPrefix(repoAction.Key, "-----BEGIN PGP PUBLIC KEY BLOCK-----") {
					reader = strings.NewReader(repoAction.Key)
				} else {
					// If only key ID is provided, we need gpg to be installed early.
					_, err := lxd.RunCommand("gpg", "--recv-keys", repoAction.Key)
					if err != nil {
						return err
					}

					var buf bytes.Buffer

					err = lxd.RunCommandWithFds(nil, &buf, "gpg", "--export", "--armor", repoAction.Key)
					if err != nil {
						return err
					}

					reader = &buf
				}

				signatureFilePath := filepath.Join("/etc/apt/trusted.gpg.d", fmt.Sprintf("%s.asc", repoAction.Name))

				f, err := os.Create(signatureFilePath)
				if err != nil {
					return err
				}
				defer f.Close()

				_, err = io.Copy(f, reader)
				if err != nil {
					return err
				}
			}

			return nil
		},
	}
}
